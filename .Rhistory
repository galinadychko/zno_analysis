predict_in_parallel = function(obj, X_test, h){
n_rows <- length(X_test)
max_threads <- 3
list_of_parts <- split_k_parts(k = max_threads, nrows = n_rows)
res <- foreach(each_part = list_of_parts, .combine = list, .multicombine = TRUE) %dopar% {unlist(each_part)}
return(do.call(rbind, res))
}
cl <- makeCluster(3, type = "FORK")
registerDoParallel(cl)
library(R6)
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
library(foreach)
library(doParallel)
source("tools/CommonTools.R")
predict_in_parallel(gnw, Xtest, 1)
stopCluster(cl)
predict_in_parallel = function(obj, X_test, h){
n_rows <- length(X_test)
max_threads <- 3
list_of_parts <- split_k_parts(k = max_threads, nrows = n_rows)
res <- foreach(each_part = list_of_parts, .combine = list, .multicombine = TRUE) %dopar% {unlist(each_part)}
# return(do.call(rbind, res))
return(res)
}
cl <- makeCluster(3, type = "FORK")
registerDoParallel(cl)
library(R6)
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
library(foreach)
library(doParallel)
source("tools/CommonTools.R")
predict_in_parallel(gnw, Xtest, 1)
stopCluster(cl)
predict_in_parallel = function(obj, X_test, h){
n_rows <- length(X_test)
max_threads <- 3
list_of_parts <- split_k_parts(k = max_threads, nrows = n_rows)
res <- foreach(each_part = list_of_parts, .combine = list, .multicombine = TRUE) %dopar% {as.vector(each_part)}
# return(do.call(rbind, res))
return(res)
}
cl <- makeCluster(3, type = "FORK")
registerDoParallel(cl)
library(R6)
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
library(foreach)
library(doParallel)
source("tools/CommonTools.R")
predict_in_parallel(gnw, Xtest, 1)
stopCluster(cl)
predict_in_parallel = function(obj, X_test, h){
n_rows <- length(X_test)
max_threads <- 3
list_of_parts <- split_k_parts(k = max_threads, nrows = n_rows)
res <- foreach(each_part = list_of_parts, .combine = list, .multicombine = TRUE) %dopar% {X_test[as.vector(each_part), ]}
return(do.call(rbind, res))
}
cl <- makeCluster(3, type = "FORK")
registerDoParallel(cl)
library(R6)
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
library(foreach)
library(doParallel)
source("tools/CommonTools.R")
predict_in_parallel(gnw, Xtest, 1)
stopCluster(cl)
Xtest
predict_in_parallel = function(obj, X_test, h){
n_rows <- length(X_test)
max_threads <- 3
list_of_parts <- split_k_parts(k = max_threads, nrows = n_rows)
res <- foreach(each_part = list_of_parts, .combine = list, .multicombine = TRUE) %dopar% {X_test[as.vector(each_part)]}
return(do.call(rbind, res))
}
cl <- makeCluster(3, type = "FORK")
registerDoParallel(cl)
library(R6)
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
library(foreach)
library(doParallel)
source("tools/CommonTools.R")
predict_in_parallel(gnw, Xtest, 1)
stopCluster(cl)
predict_in_parallel = function(obj, X_test, h){
n_rows <- length(X_test)
max_threads <- 3
list_of_parts <- split_k_parts(k = max_threads, nrows = n_rows)
res <- foreach(each_part = list_of_parts, .combine = list, .multicombine = TRUE) %dopar% {
obj$predict(X_test[as.vector(each_part)], h)
}
return(do.call(rbind, res))
}
cl <- makeCluster(3, type = "FORK")
registerDoParallel(cl)
library(R6)
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
library(foreach)
library(doParallel)
source("tools/CommonTools.R")
predict_in_parallel(gnw, Xtest, 1)
stopCluster(cl)
prediction_no_parallel
predict_in_parallel = function(obj, X_test, h){
n_rows <- length(X_test)
max_threads <- 3
list_of_parts <- split_k_parts(k = max_threads, nrows = n_rows)
res <- foreach(each_part = list_of_parts, .combine = list, .multicombine = TRUE) %dopar% {
obj$predict(X_test[as.vector(each_part)], h)
}
return(do.call(rbind, res))
}
cl <- makeCluster(3, type = "FORK")
registerDoParallel(cl)
library(R6)
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
library(foreach)
library(doParallel)
source("tools/CommonTools.R")
predictio_in_parallel <- predict_in_parallel(gnw, Xtest, 1)
stopCluster(cl)
all(prediction_no_parallel == prediction_in_parallel)
prediction_in_parallel <- gnw$predict_in_parallel(Xtest, 1)
gnw <- GeneralisedNadarayaWatson$new()
gnw$train(X, Y, W)
Xtest <- as.vector(cv_small[[1]][, "math"])
prediction_no_parallel <- gnw$predict(Xtest, 1)
all(prediction_no_parallel == prediction_in_parallel)
all(prediction_no_parallel == predictio_in_parallel)
library(foreach)
library(doParallel)
cl <- makeCluster(3, type = "FORK")
registerDoParallel(cl)
library(R6)
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
source("tools/CommonTools.R")
GeneralisedNadarayaWatson <- R6Class("GeneralisedNadarayaWatson",
public = list(
X_train = NULL,
Y_train = NULL,
A = NULL,
# max_threads = max_threads,
initialize = function(){
self$X_train <- NULL
self$Y_train <- NULL
self$A <- NULL
},
train = function(X_train, Y_train, w_coeff){
if (!is.vector(X_train) |
!is.vector(Y_train) |
!is.matrix(w_coeff))
{stop("Not correct class atributes")}
if (any(c(length(X_train), length(Y_train), nrow(w_coeff)) !=
rep(length(X_train), 3)))
{stop("Not correct input dimensions")}
self$X_train <- X_train
self$Y_train <- Y_train
self$A <- acoeff(w_coeff)
},
predict = function(X_test, h){
if (is.numeric(X_test) != TRUE | is.numeric(h) != TRUE)
{stop("Not correct class atributes")}
if (is.null(self$X_train) |
is.null(self$Y_train) |
is.null(self$A))
{stop("The model was not trained correctly")}
if (!is.null(self$A))
{if (any(is.na(self$A))) {stop("The model coefficients are not numbers")}}
results <- sapply(X_test,
function(x, h){
res <- nw_any_components(x, self$X_train, self$Y_train, h, self$A)
return(res)
}, h = h)
return(t(results))
},
predict_in_parallel = function(X_test, h){
n_rows <- length(X_test)
list_of_parts <- split_k_parts(k = 3, nrows = n_rows)
res <- foreach(each_part = list_of_parts,
.combine = list,
.multicombine = TRUE) %dopar% {
self$predict(X_test[as.vector(each_part)], h)
}
return(do.call(rbind, res))
}
)
)
gnw <- GeneralisedNadarayaWatson$new()
gnw$train(X, Y, W)
Xtest <- as.vector(cv_small[[1]][, "math"])
prediction_no_parallel <- gnw$predict(Xtest, 1)
prediction_in_parallel <- gnw$predict_in_parallel(Xtest, 1)
stopCluster(cl)
library(foreach)
library(doParallel)
cl <- makeCluster(3, type = "FORK")
registerDoParallel(cl)
library(R6)
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
source("tools/CommonTools.R")
GeneralisedNadarayaWatson <- R6Class("GeneralisedNadarayaWatson",
public = list(
X_train = NULL,
Y_train = NULL,
A = NULL,
# max_threads = max_threads,
initialize = function(){
self$X_train <- NULL
self$Y_train <- NULL
self$A <- NULL
},
train = function(X_train, Y_train, w_coeff){
if (!is.vector(X_train) |
!is.vector(Y_train) |
!is.matrix(w_coeff))
{stop("Not correct class atributes")}
if (any(c(length(X_train), length(Y_train), nrow(w_coeff)) !=
rep(length(X_train), 3)))
{stop("Not correct input dimensions")}
self$X_train <- X_train
self$Y_train <- Y_train
self$A <- acoeff(w_coeff)
},
predict = function(X_test, h){
if (is.numeric(X_test) != TRUE | is.numeric(h) != TRUE)
{stop("Not correct class atributes")}
if (is.null(self$X_train) |
is.null(self$Y_train) |
is.null(self$A))
{stop("The model was not trained correctly")}
if (!is.null(self$A))
{if (any(is.na(self$A))) {stop("The model coefficients are not numbers")}}
results <- sapply(X_test,
function(x, h){
res <- nw_any_components(x, self$X_train, self$Y_train, h, self$A)
return(res)
}, h = h)
return(t(results))
},
predict_in_parallel = function(X_test, h){
n_rows <- length(X_test)
list_of_parts <- split_k_parts(k = 3, nrows = n_rows)
res <- foreach(each_part = list_of_parts,
.combine = list,
.multicombine = TRUE,
.export = "self") %dopar% {
self$predict(X_test[as.vector(each_part)], h)
}
return(do.call(rbind, res))
}
)
)
gnw <- GeneralisedNadarayaWatson$new()
gnw$train(X, Y, W)
Xtest <- as.vector(cv_small[[1]][, "math"])
prediction_no_parallel <- gnw$predict(Xtest, 1)
prediction_in_parallel <- gnw$predict_in_parallel(Xtest, 1)
stopCluster(cl)
prediction_in_parallel
prediction_no_parallel
all(prediction_in_parallel == prediction_no_parallel)
stopCluster(cl)
source("tools/GeneralizedNadarayaWatson.R")
df <- read.csv2(file ="/home/administrator/workplace/univ/ZNOandVoating/input.csv", header=FALSE, sep=";", dec=",")
names(df) <- c("ukr","math", "pro-ukr", "radical", "oposition", "small", "not_voted")
head(df)
source("tools/DataSplitTools.R")
source("tools/DataSplitTools.R")
source("tools/DataSplitTools.R")
source("tools/DataSplitTools.R")
df <- read.csv2(file ="/home/administrator/workplace/univ/ZNOandVoating/input.csv", header=FALSE, sep=";", dec=",")
names(df) <- c("ukr","math", "pro-ukr", "radical", "oposition", "small", "not_voted")
head(df)
source("tools/DataSplitTools.R")
source("tools/DataSplitTools.R")
cv_split <- cross_validation_split(df)
cv_small <- list("1" = cv_split[[1]][1:20, ], "2"=cv_split[[2]][1:20, ])
Xtest <- as.vector(cv_small[[1]][, "math"])
X<- as.vector(cv_small[[1]][, "math"]); Y <- as.vector(cv_small[[1]][, "ukr"]); W <- as.matrix(cv_small[[1]][, -c(1, 2)])
gnw <- GeneralisedNadarayaWatson()
source("tools/GeneralizedNadarayaWatson.R")
gnw <- GeneralisedNadarayaWatson()
source("tools/GeneralizedNadarayaWatson.R")
gnw <- GeneralisedNadarayaWatson$new()
gnw$train(X, Y, W)
pred_no_parallel <- gnw$predict(X_test, 1)
pred_no_parallel <- gnw$predict(Xtest, 1)
pred_no_parallel
gnw$run_cluster()
pred_in_parallel <- gnw$predict_in_parallel(Xtest, 1)
gnw$stop_cluster()
pred_in_parallel
source("tools/DataSplitTools.R")
source("tools/GeneralizedNadarayaWatson.R")
df <- read.csv2(file ="/home/administrator/workplace/univ/ZNOandVoating/input.csv", header = FALSE, sep = ";",dec=',')
names(df) <- c("ukr", "math", "pro-ukr", "radical", "oposition", "small", "not_voted")
head(df)
cv_split <- cross_validation_split(df)
cv_small <- list("1"=cv_split[[1]][1:20, ], "2"=cv_split[[2]][1:20, ])
X<- as.vector(cv_small[[1]][, "math"]); Y <- as.vector(cv_small[[1]][, "ukr"]); W <- as.matrix(cv_small[[1]][, -c(1, 2)])
Xtest <- as.vector(cv_small[[1]][, "math"])
gnw <- GeneralisedNadarayaWatson$new()
gnw$train(X, Y, W)
pr_no_parallel <- gnw$predict(Xtest, 1)
gnw$run_cluster()
gnw$max_threads
registerDoParallel(gnw$max_threads, type = "FORK")
registerDoParallel(3, type = "FORK")
library(foreach)
library(doParallel)
registerDoParallel(3, type = "FORK")
registerDoParallel(3)
sink("/home/administrator/new_file.R")
source("tools/DataSplitTools.R")
source("tools/GeneralizedNadarayaWatson.R")
df <- read.csv2(file = "/home/administrator/workplace/univ/ZNOandVoating/input.csv",
header = FALSE, sep = ";", dec = ",")
names(df) <- c("ukr","math", "pro-ukr", "radical", "oposition", "small", "not_voted")
head(df)
cv_split <- cross_validation_split(df)
X <- as.vector(cv_split[[1]][, "math"])
Y <- as.vector(cv_split[[1]][, "ukr"])
W <- as.matrix(cv_split[[1]][, -c(1, 2)])
Xtest <- as.vector(cv_split[[2]][, "math"])
gnw <- GeneralisedNadarayaWatson$new()
gnw$train(X, Y, W)
gnw$run_cluster()
system.time({
pr1 <- gnw$predict_in_parallel(Xtest, 1)
})
gnw$stop_cluster()
W2 <- cv_split[[2]][, -c(1, 2)]
head(W2)
W2 <- as.data.frame(W2)
W2[, "max_value"] <- apply(W2, 1, max)
pro_ukr <- cv_split[[2]][W2[, "pro-ukr"] == W2["max_value"], ]
head(pro_ukr)
plot(as.vector(pro_ukr[, "math"]), as.vector(pro_ukr[, "ukr"]))
head(pro_ukr)
rownames(pro_ukr)
gnw$stop_cluster()
points(pro_ukr[, "math"], pr1[rownames(pro_ukr), 1], col = "red")
head(pr1)
rownames(pr1) <- rownames(cv_split[[2]])
head(pr1)
points(pro_ukr[, "math"], pr1[rownames(pro_ukr), 1], col = "red")
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo = TRUE)
df <- df[df$math == 0,]
df <- read.csv2(file = "/home/administrator/workplace/univ/ZNOandVoating/input.csv",
header = FALSE, sep = ";", dec = ",")
names(df) <- c("ukr","math", "pro_ukr", "radical", "oposition", "small", "not_voted")
head(df)
library(plotly)
knitr::opts_chunk$set(echo = TRUE)
library(plotly)
df <- read.csv2(file = "/home/administrator/workplace/univ/ZNOandVoating/input.csv",
header = FALSE, sep = ";", dec = ",")
names(df) <- c("ukr","math", "pro_ukr", "radical", "oposition", "small", "not_voted")
head(df)
df <- df[df$math == 0,]
plot_ly(data = df, x = ~math, y = ~ukr)
df <- read.csv2(file = "/home/administrator/workplace/univ/ZNOandVoating/input.csv",
header = FALSE, sep = ";", dec = ",")
names(df) <- c("ukr","math", "pro_ukr", "radical", "oposition", "small", "not_voted")
head(df)
df <- df[df$math != 0,]
df <- df[df$math != 0,]
plot_ly(data = df, x = ~math, y = ~ukr, mode="markers")
plot_ly(data = df, x = ~math, y = ~ukr, mode="markers", type="scatter")
apply(df[, 1, 2], 2, min)
apply(df[, c(1, 2)], 2, min)
# df[, c(1, 2)] <- df[, c(1, 2)]/200
df[, "math"] <- (df[, "math"] - 100)/200
df[, "ukr"] <- df[, "ukr"]/200
library(plotly)
source("tools/DataSplitTools.R")
source("tools/GeneralizedNadarayaWatson.R")
cv_split <- cross_validation_split(df)
part1 <- cv_split[[1]]
part2 <- cv_split[[2]]
remove(cv_split)
prediction1 <- read.csv("/home/administrator/workplace/univ/zno_project/pred1.csv")
head(prediction1)
prediction1 <- read.csv("/home/administrator/workplace/univ/zno_project/pred1.csv", row.names = TRUE)
prediction1 <- read.csv("/home/administrator/workplace/univ/zno_project/pred1.csv", row.names = 1)
head(prediction1)
library(plotly)
source("tools/DataSplitTools.R")
source("tools/GeneralizedNadarayaWatson.R")
df <- read.csv2(file = "/home/administrator/workplace/univ/ZNOandVoating/input.csv",
header = FALSE, sep = ";", dec = ",")
names(df) <- c("ukr","math", "pro_ukr", "radical", "oposition", "small", "not_voted")
# head(df)
df <- df[df$math != 0,]
cv_split <- cross_validation_split(df)
part1 <- cv_split[[1]]
part2 <- cv_split[[2]]
remove(cv_split)
Xtrain <- as.vector(part1[, "math"])
Ytrain <- as.vector(part1[, "ukr"])
Wtrain <- as.matrix(part1[, -c(1, 2)])
Xtest <- as.vector(part2[, "math"])
gnw <- GeneralisedNadarayaWatson$new()
gnw$train(Xtrain, Ytrain, Wtrain)
gnw$run_cluster()
prediction1 <- gnw$predict_in_parallel(Xtest, 1)
gnw$stop_cluster()
rownames(prediction1) <- rownames(part2)
write.csv(prediction1, file = "/home/administrator/workplace/univ/zno_project/pred1.csv")
prediction1 <- read.csv("/home/administrator/workplace/univ/zno_project/pred1.csv", row.names = 1)
head(prediction1)
head(df)
Wtest <- part1[, -c(1, 2)]
Wtest[, "max_value"] <- apply(Wtest, 1, max)
Wtest <- as.data.frame(part1[, -c(1, 2)])
Wtest[, "max_value"] <- apply(Wtest, 1, max)
pro_ukr <- part2[Wtest[, "pro_ukr"] == Wtest["max_value"], ]
head(pro_ukr)
radical <- part2[Wtest[, "radical"] == Wtest["max_value"], ]
head(radical
)
radical <- part2[Wtest[, "radical"] == Wtest["max_value"], ]
head(radical)
max(part1[, "radica"])
max(part1[, "radical"])
max(part2[, "radical"])
min(part2[, "radical"])
opposition <- part2[Wtest[, "oposition"] == Wtest["max_value"], ]
head(opposition)
max(Wtest[, "oposition"])
min(Wtest[, "oposition"])
small <- part2[Wtest[, "small"] == Wtest["max_value"], ]
head(small)
not_voted <- part2[Wtest[, "not_voted"] == Wtest["max_value"], ]
head(not_voted)
plot_ly(data = pro_ukr, x = ~math, y = ~ukr, mode = "markers", type = "scatter") %>%
add_trace(x=pro_ukr[, "math"], y = prediction1[rownames(pro_ukr), 1], name = 'trace 1', mode = 'lines+markers')
plot_ly(data = as.data.frame(pro_ukr), x = ~math, y = ~ukr, mode = "markers", type = "scatter") %>%
add_trace(x=pro_ukr[, "math"], y = prediction1[rownames(pro_ukr), 1], name = 'trace 1', mode = 'lines+markers')
plot_ly(data = as.data.frame(pro_ukr), x = ~math, y = ~ukr, mode = "markers", type = "scatter") %>%
add_trace(x=pro_ukr[, "math"], y = prediction1[rownames(pro_ukr), 1], name = 'trace 1', mode = 'markers')
plot_ly(data = as.data.frame(not_voted), x = ~math, y = ~ukr, mode = "markers", type = "scatter") %>%
add_trace(x=not_voted[, "math"], y = prediction1[rownames(not_voted), 5], name = 'trace 1', mode = 'markers')
source('~/.active-rstudio-document', echo=TRUE)
library("Hmisc")
library(Hmisc)
install.packages("Hmisc")
library(Hmisc)
knitr::opts_chunk$set(echo = TRUE)
library(plotly)
library(Hmisc)
source("tools/DataSplitTools.R")
source("tools/GeneralizedNadarayaWatson.R")
df <- read.csv2(file = "/home/administrator/workplace/univ/ZNOandVoating/input.csv",
header = FALSE, sep = ";", dec = ",")
names(df) <- c("ukr","math", "pro_ukr", "radical", "opposition", "small", "not_voted")
df[, -c(1, 2)] <- df[, -c(1, 2)]/100
head(df)
describe(df)
describe(df)
df <- read.csv2(file = "/home/administrator/workplace/univ/ZNOandVoating/input.csv",
header = FALSE, sep = ";", dec = ",")
names(df) <- c("ukr","math", "pro_ukr", "radical", "opposition", "small", "not_voted")
df[, -c(1, 2)] <- df[, -c(1, 2)]
head(df)
describe(df)
df <- df[df$math != 0,]
describe(df)
df <- read.csv2(file = "/home/administrator/workplace/univ/ZNOandVoating/input.csv",
header = FALSE, sep = ";", dec = ",")
names(df) <- c("ukr","math", "pro_ukr", "radical", "opposition", "small", "not_voted")
df[, -c(1, 2)] <- df[, -c(1, 2)]
head(df)
describe(df)
plot_ly(x = df[, "math"], type = "histogram")
df <- df[df$math != 0,]
plot_ly(x = df[, "math"], type = "histogram")
plot_ly(data = df, x = ~math, y = ~ukr, mode = "markers", type = "scatter")
W <- as.data.frame(df[, -c(1, 2)])
W[, "max_value"] <- apply(W, 1, max)
pro_ukr <- df[W[, "pro_ukr"] == W["max_value"], ]
head(pro_ukr)
radical <- df[W[, "radical"] == W["max_value"], ]
head(radical)
small <- df[W[, "small"] == W["max_value"], ]
head(small)
not_voted <- df[W[, "not_voted"] == W["max_value"], ]
head(not_voted)
plot_ly(x = df[, "math"], type = "histogram")
small <- df[W[, "small"] == W["max_value"], ]
head(small)
plot_ly(x = pro_ukr[, "math"], type = "histogram")
plot_ly(x = radical[, "math"], type = "histogram")
plot_ly(x = opposition[, "math"], type = "histogram")
opposition <- df[W[, "opposition"] == W["max_value"], ]
head(opposition)
plot_ly(x = opposition[, "math"], type = "histogram")
plot_ly(x = small[, "math"], type = "histogram")
plot_ly(x = not_voted[, "math"], type = "histogram")
plot_ly(x = not_voted[, "ukr"], type = "histogram")
plot_ly(x = pro_ukr[, "ukr"], type = "histogram")
plot_ly(x = not_voted[, "ukr"], type = "histogram")
plot_ly(x = pro_ukr[, "ukr"], type = "histogram")
