A = NULL,
max_threads = max_threads,
initialize = function(){
self$X_train <- NULL
self$Y_train <- NULL
self$A <- NULL
self$max_threads <- max_threads
},
train = function(X_train, Y_train, W_train){
if (!is.vector(X_train, mode = "numeric") |
!is.vector(Y_train, mode = "numeric") |
!is.matrix(W_train))
{stop("Not correct class attributes")}
if (any(c(length(X_train), length(Y_train), nrow(W_train)) !=
rep(length(X_train), 3)))
{stop("Not correct input dimensions")}
self$X_train <- X_train
self$Y_train <- Y_train
self$A <- acoeff(W_train)
},
predict = function(X_test, W_test, h){
print("X_test:"); print(X_test)
print("W_test:"); print(W_test)
print("h:"); print(h)
print(self$A)
if (is.numeric(X_test) != TRUE |
is.numeric(h) != TRUE |
is.matrix(W_test) != TRUE)
{stop("Not correct class attributes")}
if (is.null(self$X_train) |
is.null(self$Y_train) |
is.null(self$A))
{stop("The model was not trained correctly")}
if (!is.null(self$A))
{if (any(is.na(self$A))) {stop("The model coefficients are not numbers")}}
if (length(X_test) != nrow(W_test))
{stop("Not correct input dimensions")}
results <- sapply(X_test,
function(x, h){
res <- nw_any_components(x, self$X_train, self$Y_train, h, self$A)
return(res)
}, h = h)
return(list("prediction" = t(results), "A_test" = acoeff(W_test)))
},
predict_in_parallel = function(X_test, W_test, h){
if (is.numeric(X_test) != TRUE |
is.numeric(h) != TRUE |
is.matrix(W_test) != TRUE)
{stop("Not correct class attributes")}
if (is.null(self$X_train) |
is.null(self$Y_train) |
is.null(self$A))
{stop("The model was not trained correctly")}
if (!is.null(self$A))
{if (any(is.na(self$A))) {stop("The model coefficients are not numbers")}}
if (length(X_test) != nrow(W_test))
{stop("Not correct input dimensions")}
n_rows <- length(X_test)
list_of_parts <- split_k_parts(k = self$max_threads, nrows = n_rows)
res <- foreach(each_part = list_of_parts,
.combine = list,
.multicombine = TRUE,
.export = c("self", "W_test", "h")) %dopar% {
pr <- self$predict(as.vector(X_test[each_part]),
matrix(W_test[each_part, ], nrow = length(each_part)),
h)
pr
}
return(list("prediction" = res))
},
stop_cluster = function(){
stopImplicitCluster()
},
run_cluster = function(max_threads = self$max_threads){
self$max_threads = max_threads
registerDoParallel(self$max_threads)
}
)
)
instance$stop_cluster()
instance$stop_cluster()
instance <- GeneralisedNadarayaWatson$new()
instance$train(X_train, Y_train, w_coeff)
instance$run_cluster(2)
instance$predict_in_parallel(X_test, w_coeff, 1)
instance$stop_cluster()
library(R6)
library(foreach)
library(doParallel)
max_threads <- detectCores() - 1
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
source("tools/CommonTools.R")
GeneralisedNadarayaWatson <- R6Class("GeneralisedNadarayaWatson",
public = list(
X_train = NULL,
Y_train = NULL,
A = NULL,
max_threads = max_threads,
initialize = function(){
self$X_train <- NULL
self$Y_train <- NULL
self$A <- NULL
self$max_threads <- max_threads
},
train = function(X_train, Y_train, W_train){
if (!is.vector(X_train, mode = "numeric") |
!is.vector(Y_train, mode = "numeric") |
!is.matrix(W_train))
{stop("Not correct class attributes")}
if (any(c(length(X_train), length(Y_train), nrow(W_train)) !=
rep(length(X_train), 3)))
{stop("Not correct input dimensions")}
self$X_train <- X_train
self$Y_train <- Y_train
self$A <- acoeff(W_train)
},
predict = function(X_test, W_test, h){
print("X_test:"); print(X_test)
print("W_test:"); print(W_test)
print("h:"); print(h)
print(self$A)
if (is.numeric(X_test) != TRUE |
is.numeric(h) != TRUE |
is.matrix(W_test) != TRUE)
{stop("Not correct class attributes")}
if (is.null(self$X_train) |
is.null(self$Y_train) |
is.null(self$A))
{stop("The model was not trained correctly")}
if (!is.null(self$A))
{if (any(is.na(self$A))) {stop("The model coefficients are not numbers")}}
if (length(X_test) != nrow(W_test))
{stop("Not correct input dimensions")}
results <- sapply(X_test,
function(x, h){
res <- nw_any_components(x, self$X_train, self$Y_train, h, self$A)
return(res)
}, h = h)
return(list("prediction" = t(results), "A_test" = acoeff(W_test)))
},
predict_in_parallel = function(X_test, W_test, h){
if (is.numeric(X_test) != TRUE |
is.numeric(h) != TRUE |
is.matrix(W_test) != TRUE)
{stop("Not correct class attributes")}
if (is.null(self$X_train) |
is.null(self$Y_train) |
is.null(self$A))
{stop("The model was not trained correctly")}
if (!is.null(self$A))
{if (any(is.na(self$A))) {stop("The model coefficients are not numbers")}}
if (length(X_test) != nrow(W_test))
{stop("Not correct input dimensions")}
n_rows <- length(X_test)
list_of_parts <- split_k_parts(k = self$max_threads, nrows = n_rows)
res <- foreach(each_part = list_of_parts,
.combine = list,
.multicombine = TRUE,
.export = c("self", "W_test", "h")) %dopar% {
pr <- list(as.vector(X_test[each_part]),
matrix(W_test[each_part, ], nrow = length(each_part)),
h)
pr
}
return(list("prediction" = res))
},
stop_cluster = function(){
stopImplicitCluster()
},
run_cluster = function(max_threads = self$max_threads){
self$max_threads = max_threads
registerDoParallel(self$max_threads)
}
)
)
instance$stop_cluster()
instance$stop_cluster()
instance <- GeneralisedNadarayaWatson$new()
instance$train(X_train, Y_train, w_coeff)
instance$run_cluster(2)
instance$predict_in_parallel(X_test, w_coeff, 1)
library(R6)
library(foreach)
library(doParallel)
max_threads <- detectCores() - 1
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
source("tools/CommonTools.R")
GeneralisedNadarayaWatson <- R6Class("GeneralisedNadarayaWatson",
public = list(
X_train = NULL,
Y_train = NULL,
A = NULL,
max_threads = max_threads,
initialize = function(){
self$X_train <- NULL
self$Y_train <- NULL
self$A <- NULL
self$max_threads <- max_threads
},
train = function(X_train, Y_train, W_train){
if (!is.vector(X_train, mode = "numeric") |
!is.vector(Y_train, mode = "numeric") |
!is.matrix(W_train))
{stop("Not correct class attributes")}
if (any(c(length(X_train), length(Y_train), nrow(W_train)) !=
rep(length(X_train), 3)))
{stop("Not correct input dimensions")}
self$X_train <- X_train
self$Y_train <- Y_train
self$A <- acoeff(W_train)
},
predict = function(X_test, W_test, h){
print("X_test:"); print(X_test)
print("W_test:"); print(W_test)
print("h:"); print(h)
print(self$A)
if (is.numeric(X_test) != TRUE |
is.numeric(h) != TRUE |
is.matrix(W_test) != TRUE)
{stop("Not correct class attributes")}
if (is.null(self$X_train) |
is.null(self$Y_train) |
is.null(self$A))
{stop("The model was not trained correctly")}
if (!is.null(self$A))
{if (any(is.na(self$A))) {stop("The model coefficients are not numbers")}}
if (length(X_test) != nrow(W_test))
{stop("Not correct input dimensions")}
results <- sapply(X_test,
function(x, h){
res <- nw_any_components(x, self$X_train, self$Y_train, h, self$A)
return(res)
}, h = h)
return(list("prediction" = t(results), "A_test" = acoeff(W_test)))
},
predict_in_parallel = function(X_test, W_test, h){
if (is.numeric(X_test) != TRUE |
is.numeric(h) != TRUE |
is.matrix(W_test) != TRUE)
{stop("Not correct class attributes")}
if (is.null(self$X_train) |
is.null(self$Y_train) |
is.null(self$A))
{stop("The model was not trained correctly")}
if (!is.null(self$A))
{if (any(is.na(self$A))) {stop("The model coefficients are not numbers")}}
if (length(X_test) != nrow(W_test))
{stop("Not correct input dimensions")}
n_rows <- length(X_test)
list_of_parts <- split_k_parts(k = self$max_threads, nrows = n_rows)
res <- foreach(each_part = list_of_parts,
.combine = list,
.multicombine = TRUE,
.export = c("self", "W_test", "h")) %dopar% {
pr <- list(as.vector(X_test[each_part]),
matrix(W_test[each_part, ], nrow = length(each_part)),
h)
nw_any_components(x=X_test[each_part],
X_train = self$X_train,
Y_train = self$Y_train,
h = h, A = self$A)
pr
}
return(list("prediction" = res))
},
stop_cluster = function(){
stopImplicitCluster()
},
run_cluster = function(max_threads = self$max_threads){
self$max_threads = max_threads
registerDoParallel(self$max_threads)
}
)
)
instance$stop_cluster()
instance <- GeneralisedNadarayaWatson$new()
instance$train(X_train, Y_train, w_coeff)
instance$run_cluster(2)
instance$predict_in_parallel(X_test, w_coeff, 1)
instance$stop_cluster()
library(R6)
library(foreach)
library(doParallel)
max_threads <- detectCores() - 1
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
source("tools/CommonTools.R")
GeneralisedNadarayaWatson <- R6Class("GeneralisedNadarayaWatson",
public = list(
X_train = NULL,
Y_train = NULL,
A = NULL,
max_threads = max_threads,
initialize = function(){
self$X_train <- NULL
self$Y_train <- NULL
self$A <- NULL
self$max_threads <- max_threads
},
train = function(X_train, Y_train, W_train){
if (!is.vector(X_train, mode = "numeric") |
!is.vector(Y_train, mode = "numeric") |
!is.matrix(W_train))
{stop("Not correct class attributes")}
if (any(c(length(X_train), length(Y_train), nrow(W_train)) !=
rep(length(X_train), 3)))
{stop("Not correct input dimensions")}
self$X_train <- X_train
self$Y_train <- Y_train
self$A <- acoeff(W_train)
},
predict = function(X_test, W_test, h){
print("X_test:"); print(X_test)
print("W_test:"); print(W_test)
print("h:"); print(h)
print(self$A)
if (is.numeric(X_test) != TRUE |
is.numeric(h) != TRUE |
is.matrix(W_test) != TRUE)
{stop("Not correct class attributes")}
if (is.null(self$X_train) |
is.null(self$Y_train) |
is.null(self$A))
{stop("The model was not trained correctly")}
if (!is.null(self$A))
{if (any(is.na(self$A))) {stop("The model coefficients are not numbers")}}
if (length(X_test) != nrow(W_test))
{stop("Not correct input dimensions")}
results <- sapply(X_test,
function(x, h){
res <- nw_any_components(x, self$X_train, self$Y_train, h, self$A)
return(res)
}, h = h)
return(list("prediction" = t(results), "A_test" = acoeff(W_test)))
},
predict_in_parallel = function(X_test, W_test, h){
if (is.numeric(X_test) != TRUE |
is.numeric(h) != TRUE |
is.matrix(W_test) != TRUE)
{stop("Not correct class attributes")}
if (is.null(self$X_train) |
is.null(self$Y_train) |
is.null(self$A))
{stop("The model was not trained correctly")}
if (!is.null(self$A))
{if (any(is.na(self$A))) {stop("The model coefficients are not numbers")}}
if (length(X_test) != nrow(W_test))
{stop("Not correct input dimensions")}
n_rows <- length(X_test)
list_of_parts <- split_k_parts(k = self$max_threads, nrows = n_rows)
res <- foreach(each_part = list_of_parts,
.combine = list,
.multicombine = TRUE,
.export = c("self", "W_test", "h")) %dopar% {
pr <- list(as.vector(X_test[each_part]),
matrix(W_test[each_part, ], nrow = length(each_part)),
h)
pr <- nw_any_components(x=X_test[each_part],
X_train = self$X_train,
Y_train = self$Y_train,
h = h, A = self$A)
pr
}
return(list("prediction" = res))
},
stop_cluster = function(){
stopImplicitCluster()
},
run_cluster = function(max_threads = self$max_threads){
self$max_threads = max_threads
registerDoParallel(self$max_threads)
}
)
)
instance$stop_cluster()
instance <- GeneralisedNadarayaWatson$new()
instance$train(X_train, Y_train, w_coeff)
instance$run_cluster(2)
instance$predict_in_parallel(X_test, w_coeff, 1)
instance$stop_cluster()
sapply(1, function(x){nw_any_components(0, X_train, Y_train, 1, instance$A)})
sapply(0.5, function(x){nw_any_components(x, X_train, Y_train, 1, instance$A)})
library(R6)
library(foreach)
library(doParallel)
max_threads <- detectCores() - 1
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
source("tools/CommonTools.R")
GeneralisedNadarayaWatson <- R6Class("GeneralisedNadarayaWatson",
public = list(
X_train = NULL,
Y_train = NULL,
A = NULL,
max_threads = max_threads,
initialize = function(){
self$X_train <- NULL
self$Y_train <- NULL
self$A <- NULL
self$max_threads <- max_threads
},
train = function(X_train, Y_train, W_train){
if (!is.vector(X_train, mode = "numeric") |
!is.vector(Y_train, mode = "numeric") |
!is.matrix(W_train))
{stop("Not correct class attributes")}
if (any(c(length(X_train), length(Y_train), nrow(W_train)) !=
rep(length(X_train), 3)))
{stop("Not correct input dimensions")}
self$X_train <- X_train
self$Y_train <- Y_train
self$A <- acoeff(W_train)
},
predict = function(X_test, W_test, h){
print("X_test:"); print(X_test)
print("W_test:"); print(W_test)
print("h:"); print(h)
print(self$A)
if (is.numeric(X_test) != TRUE |
is.numeric(h) != TRUE |
is.matrix(W_test) != TRUE)
{stop("Not correct class attributes")}
if (is.null(self$X_train) |
is.null(self$Y_train) |
is.null(self$A))
{stop("The model was not trained correctly")}
if (!is.null(self$A))
{if (any(is.na(self$A))) {stop("The model coefficients are not numbers")}}
if (length(X_test) != nrow(W_test))
{stop("Not correct input dimensions")}
results <- sapply(X_test,
function(x, h){
res <- nw_any_components(x, self$X_train, self$Y_train, h, self$A)
return(res)
}, h = h)
return(list("prediction" = t(results), "A_test" = acoeff(W_test)))
},
predict_in_parallel = function(X_test, W_test, h){
if (is.numeric(X_test) != TRUE |
is.numeric(h) != TRUE |
is.matrix(W_test) != TRUE)
{stop("Not correct class attributes")}
if (is.null(self$X_train) |
is.null(self$Y_train) |
is.null(self$A))
{stop("The model was not trained correctly")}
if (!is.null(self$A))
{if (any(is.na(self$A))) {stop("The model coefficients are not numbers")}}
if (length(X_test) != nrow(W_test))
{stop("Not correct input dimensions")}
n_rows <- length(X_test)
list_of_parts <- split_k_parts(k = self$max_threads, nrows = n_rows)
res <- foreach(each_part = list_of_parts,
.combine = list,
.multicombine = TRUE,
.export = c("self", "W_test", "h")) %dopar% {
pr <- list(as.vector(X_test[each_part]),
matrix(W_test[each_part, ], nrow = length(each_part)),
h)
pr <- self$predict(X_test[each_part],
matrix(W_test[each_part, ], nrow = length(each_part)), h)
pr
}
return(list("prediction" = res))
},
stop_cluster = function(){
stopImplicitCluster()
},
run_cluster = function(max_threads = self$max_threads){
self$max_threads = max_threads
registerDoParallel(self$max_threads)
}
)
)
instance$stop_cluster()
instance <- GeneralisedNadarayaWatson$new()
instance$train(X_train, Y_train, w_coeff)
instance$run_cluster(2)
instance$predict_in_parallel(X_test, w_coeff, 1)
instance$stop_cluster()
library(plotly)
library(Hmisc)
library(WVPlots)
library(plyr)
source("tools/DataSplitTools.R")
source("tools/GeneralizedNadarayaWatson.R")
source("tools/CommonTools.R")
source("tools/CrossValTools.R")
df <- read.csv2(file = "data/ZNOandVoating/input.csv",
header = FALSE, sep = ";", dec = ",")
names(df) <- c("ukr","math", "pro_ukr", "radical", "opposition", "small", "not_voted")
df[, -c(1, 2)] <- df[, -c(1, 2)]/100
df <- df[(df$math != 0) & (df$ukr != 0) ,]
train_test_list <- train_test_split(df, ratio=0.80)
train <- train_test_list[["train"]]
test <- train_test_list[["test"]]
cv_split <- cross_validation_split(train)
remove(df)
library(plotly)
library(Hmisc)
library(WVPlots)
library(plyr)
source("tools/DataSplitTools.R")
source("tools/GeneralizedNadarayaWatson.R")
source("tools/CommonTools.R")
source("tools/CrossValTools.R")
h_range <- c(seq(0.1, 1, 0.1), seq(1.5, 5, 0.5))
GNW_cv_results <- GNWcv_across_h(h_range, cv_split, "math", "ukr",
c("pro_ukr", "radical", "opposition", "small", "not_voted"),
use_parallel = TRUE)
