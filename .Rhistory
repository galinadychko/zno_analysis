},
predict = function(X_test, h){
if (is.numeric(X_test) != TRUE | is.numeric(h) != TRUE)
{stop("Not correct class atributes")}
if (is.null(self$X_train) |
is.null(self$Y_train) |
is.null(self$A))
{stop("The model was not trained correctly")}
if (!is.null(self$A))
{if (any(is.na(self$A))) {stop("The model coefficients are not numbers")}}
results <- sapply(X_test,
function(x, h){
res <- nw_any_components(x, self$X_train, self$Y_train, h, self$A)
return(res)
}, h = h)
return(t(results))
}
)
)
gnw <- GeneralisedNadarayaWatson$new()
gnw$train(X, Y, W)
Xtest <- as.vector(cv_small[[1]][, "math"])
prediction_no_parallel <- gnw$predict(Xtest, 1)
prediction_no_parallel
predict_in_parallel = function(obj, X_test, h){
res <- foreach(1:2, .combine = list, .multicombine = TRUE) %dopar% {obj$predict(168, 1)}
return(res)
}
cl <- makeCluster(3)
registerDoParallel(cl)
predict_in_parallel(gnw, Xtest, 1)
stopCluster(cl)
predict_in_parallel = function(obj, X_test, h){
res <- foreach(1:2, .combine = list, .multicombine = TRUE, .export = "obj") %dopar% {obj$predict(168, 1)}
return(res)
}
cl <- makeCluster(3)
registerDoParallel(cl)
predict_in_parallel(gnw, Xtest, 1)
stopCluster(cl)
predict_in_parallel = function(obj, X_test, h){
res <- foreach(1:2, .combine = list, .multicombine = TRUE, .export = "tools") %dopar% {obj$predict(168, 1)}
return(res)
}
cl <- makeCluster(3, type = "FORK")
registerDoParallel(cl)
predict_in_parallel(gnw, Xtest, 1)
stopCluster(cl)
predict_in_parallel = function(obj, X_test, h){
res <- foreach(1:2, .combine = list, .multicombine = TRUE, .export = "tools/NadarayaWatson.R") %dopar% {obj$predict(168, 1)}
return(res)
}
cl <- makeCluster(3, type = "FORK")
registerDoParallel(cl)
predict_in_parallel(gnw, Xtest, 1)
stopCluster(cl)
predict_in_parallel = function(obj, X_test, h){
res <- foreach(1:2, .combine = list, .multicombine = TRUE, .export = "base") %dopar% {obj$predict(168, 1)}
return(res)
}
cl <- makeCluster(3, type = "FORK")
registerDoParallel(cl)
predict_in_parallel(gnw, Xtest, 1)
stopCluster(cl)
predict_in_parallel = function(obj, X_test, h){
res <- foreach(1:2, .combine = list, .multicombine = TRUE, .export = "base") %dopar% {obj$predict(168, 1)}
return(res)
}
cl <- makeCluster(3, type = "FORK")
registerDoParallel(cl)
library(R6)
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
library(foreach)
library(doParallel)
source("tools/CommonTools.R")
predict_in_parallel(gnw, Xtest, 1)
stopCluster(cl)
predict_in_parallel = function(obj, X_test, h){
res <- foreach(1:2, .combine = list, .multicombine = TRUE) %dopar% {obj$predict(168, 1)}
return(res)
}
cl <- makeCluster(3, type = "FORK")
registerDoParallel(cl)
library(R6)
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
library(foreach)
library(doParallel)
source("tools/CommonTools.R")
predict_in_parallel(gnw, Xtest, 1)
stopCluster(cl)
predict_in_parallel = function(obj, X_test, h){
res <- foreach(1:2, .combine = list, .multicombine = TRUE) %dopar% {obj$predict(X_test, 1)}
return(res)
}
cl <- makeCluster(3, type = "FORK")
registerDoParallel(cl)
library(R6)
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
library(foreach)
library(doParallel)
source("tools/CommonTools.R")
predict_in_parallel(gnw, Xtest, 1)
stopCluster(cl)
predict_in_parallel = function(obj, X_test, h){
n_rows <- length(X_test)
max_threads <- 3
list_of_parts <- split_k_parts(k = max_threads, nrows = n_rows)
res <- foreach(list_of_parts, .combine = list, .multicombine = TRUE) %dopar% {obj$predict(X_test, 1)}
return(res)
}
cl <- makeCluster(3, type = "FORK")
registerDoParallel(cl)
library(R6)
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
library(foreach)
library(doParallel)
source("tools/CommonTools.R")
predict_in_parallel(gnw, Xtest, 1)
stopCluster(cl)
predict_in_parallel = function(obj, X_test, h){
n_rows <- length(X_test)
max_threads <- 3
list_of_parts <- split_k_parts(k = max_threads, nrows = n_rows)
res <- foreach(list_of_parts, .combine = list, .multicombine = TRUE) %dopar% {obj$predict(X_test, 1)}
return(do.call(rbind, res))
}
cl <- makeCluster(3, type = "FORK")
registerDoParallel(cl)
library(R6)
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
library(foreach)
library(doParallel)
source("tools/CommonTools.R")
predict_in_parallel(gnw, Xtest, 1)
stopCluster(cl)
predict_in_parallel = function(obj, X_test, h){
n_rows <- length(X_test)
max_threads <- 3
list_of_parts <- split_k_parts(k = max_threads, nrows = n_rows)
res <- foreach(list_of_parts, .combine = list, .multicombine = TRUE) %dopar% {obj$predict(X_test[unlist(list_of_parts), ], 1)}
return(do.call(rbind, res))
}
cl <- makeCluster(3, type = "FORK")
registerDoParallel(cl)
library(R6)
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
library(foreach)
library(doParallel)
source("tools/CommonTools.R")
predict_in_parallel(gnw, Xtest, 1)
stopCluster(cl)
predict_in_parallel = function(obj, X_test, h){
n_rows <- length(X_test)
max_threads <- 3
list_of_parts <- split_k_parts(k = max_threads, nrows = n_rows)
res <- foreach(list_of_parts, .combine = list, .multicombine = TRUE) %dopar% {X_test[unlist(list_of_parts), ]}
return(do.call(rbind, res))
}
cl <- makeCluster(3, type = "FORK")
registerDoParallel(cl)
library(R6)
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
library(foreach)
library(doParallel)
source("tools/CommonTools.R")
predict_in_parallel(gnw, Xtest, 1)
stopCluster(cl)
predict_in_parallel = function(obj, X_test, h){
n_rows <- length(X_test)
max_threads <- 3
list_of_parts <- split_k_parts(k = max_threads, nrows = n_rows)
res <- foreach(each_part = list_of_parts, .combine = list, .multicombine = TRUE) %dopar% {X_test[unlist(each_part), ]}
return(do.call(rbind, res))
}
cl <- makeCluster(3, type = "FORK")
registerDoParallel(cl)
library(R6)
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
library(foreach)
library(doParallel)
source("tools/CommonTools.R")
predict_in_parallel(gnw, Xtest, 1)
stopCluster(cl)
predict_in_parallel = function(obj, X_test, h){
n_rows <- length(X_test)
max_threads <- 3
list_of_parts <- split_k_parts(k = max_threads, nrows = n_rows)
res <- foreach(each_part = list_of_parts, .combine = list, .multicombine = TRUE) %dopar% {unlist(each_part)}
return(do.call(rbind, res))
}
cl <- makeCluster(3, type = "FORK")
registerDoParallel(cl)
library(R6)
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
library(foreach)
library(doParallel)
source("tools/CommonTools.R")
predict_in_parallel(gnw, Xtest, 1)
stopCluster(cl)
predict_in_parallel = function(obj, X_test, h){
n_rows <- length(X_test)
max_threads <- 3
list_of_parts <- split_k_parts(k = max_threads, nrows = n_rows)
res <- foreach(each_part = list_of_parts, .combine = list, .multicombine = TRUE) %dopar% {unlist(each_part)}
# return(do.call(rbind, res))
return(res)
}
cl <- makeCluster(3, type = "FORK")
registerDoParallel(cl)
library(R6)
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
library(foreach)
library(doParallel)
source("tools/CommonTools.R")
predict_in_parallel(gnw, Xtest, 1)
stopCluster(cl)
predict_in_parallel = function(obj, X_test, h){
n_rows <- length(X_test)
max_threads <- 3
list_of_parts <- split_k_parts(k = max_threads, nrows = n_rows)
res <- foreach(each_part = list_of_parts, .combine = list, .multicombine = TRUE) %dopar% {as.vector(each_part)}
# return(do.call(rbind, res))
return(res)
}
cl <- makeCluster(3, type = "FORK")
registerDoParallel(cl)
library(R6)
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
library(foreach)
library(doParallel)
source("tools/CommonTools.R")
predict_in_parallel(gnw, Xtest, 1)
stopCluster(cl)
predict_in_parallel = function(obj, X_test, h){
n_rows <- length(X_test)
max_threads <- 3
list_of_parts <- split_k_parts(k = max_threads, nrows = n_rows)
res <- foreach(each_part = list_of_parts, .combine = list, .multicombine = TRUE) %dopar% {X_test[as.vector(each_part), ]}
return(do.call(rbind, res))
}
cl <- makeCluster(3, type = "FORK")
registerDoParallel(cl)
library(R6)
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
library(foreach)
library(doParallel)
source("tools/CommonTools.R")
predict_in_parallel(gnw, Xtest, 1)
stopCluster(cl)
Xtest
predict_in_parallel = function(obj, X_test, h){
n_rows <- length(X_test)
max_threads <- 3
list_of_parts <- split_k_parts(k = max_threads, nrows = n_rows)
res <- foreach(each_part = list_of_parts, .combine = list, .multicombine = TRUE) %dopar% {X_test[as.vector(each_part)]}
return(do.call(rbind, res))
}
cl <- makeCluster(3, type = "FORK")
registerDoParallel(cl)
library(R6)
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
library(foreach)
library(doParallel)
source("tools/CommonTools.R")
predict_in_parallel(gnw, Xtest, 1)
stopCluster(cl)
predict_in_parallel = function(obj, X_test, h){
n_rows <- length(X_test)
max_threads <- 3
list_of_parts <- split_k_parts(k = max_threads, nrows = n_rows)
res <- foreach(each_part = list_of_parts, .combine = list, .multicombine = TRUE) %dopar% {
obj$predict(X_test[as.vector(each_part)], h)
}
return(do.call(rbind, res))
}
cl <- makeCluster(3, type = "FORK")
registerDoParallel(cl)
library(R6)
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
library(foreach)
library(doParallel)
source("tools/CommonTools.R")
predict_in_parallel(gnw, Xtest, 1)
stopCluster(cl)
prediction_no_parallel
predict_in_parallel = function(obj, X_test, h){
n_rows <- length(X_test)
max_threads <- 3
list_of_parts <- split_k_parts(k = max_threads, nrows = n_rows)
res <- foreach(each_part = list_of_parts, .combine = list, .multicombine = TRUE) %dopar% {
obj$predict(X_test[as.vector(each_part)], h)
}
return(do.call(rbind, res))
}
cl <- makeCluster(3, type = "FORK")
registerDoParallel(cl)
library(R6)
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
library(foreach)
library(doParallel)
source("tools/CommonTools.R")
predictio_in_parallel <- predict_in_parallel(gnw, Xtest, 1)
stopCluster(cl)
all(prediction_no_parallel == prediction_in_parallel)
prediction_in_parallel <- gnw$predict_in_parallel(Xtest, 1)
gnw <- GeneralisedNadarayaWatson$new()
gnw$train(X, Y, W)
Xtest <- as.vector(cv_small[[1]][, "math"])
prediction_no_parallel <- gnw$predict(Xtest, 1)
all(prediction_no_parallel == prediction_in_parallel)
all(prediction_no_parallel == predictio_in_parallel)
library(foreach)
library(doParallel)
cl <- makeCluster(3, type = "FORK")
registerDoParallel(cl)
library(R6)
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
source("tools/CommonTools.R")
GeneralisedNadarayaWatson <- R6Class("GeneralisedNadarayaWatson",
public = list(
X_train = NULL,
Y_train = NULL,
A = NULL,
# max_threads = max_threads,
initialize = function(){
self$X_train <- NULL
self$Y_train <- NULL
self$A <- NULL
},
train = function(X_train, Y_train, w_coeff){
if (!is.vector(X_train) |
!is.vector(Y_train) |
!is.matrix(w_coeff))
{stop("Not correct class atributes")}
if (any(c(length(X_train), length(Y_train), nrow(w_coeff)) !=
rep(length(X_train), 3)))
{stop("Not correct input dimensions")}
self$X_train <- X_train
self$Y_train <- Y_train
self$A <- acoeff(w_coeff)
},
predict = function(X_test, h){
if (is.numeric(X_test) != TRUE | is.numeric(h) != TRUE)
{stop("Not correct class atributes")}
if (is.null(self$X_train) |
is.null(self$Y_train) |
is.null(self$A))
{stop("The model was not trained correctly")}
if (!is.null(self$A))
{if (any(is.na(self$A))) {stop("The model coefficients are not numbers")}}
results <- sapply(X_test,
function(x, h){
res <- nw_any_components(x, self$X_train, self$Y_train, h, self$A)
return(res)
}, h = h)
return(t(results))
},
predict_in_parallel = function(X_test, h){
n_rows <- length(X_test)
list_of_parts <- split_k_parts(k = 3, nrows = n_rows)
res <- foreach(each_part = list_of_parts,
.combine = list,
.multicombine = TRUE) %dopar% {
self$predict(X_test[as.vector(each_part)], h)
}
return(do.call(rbind, res))
}
)
)
gnw <- GeneralisedNadarayaWatson$new()
gnw$train(X, Y, W)
Xtest <- as.vector(cv_small[[1]][, "math"])
prediction_no_parallel <- gnw$predict(Xtest, 1)
prediction_in_parallel <- gnw$predict_in_parallel(Xtest, 1)
stopCluster(cl)
library(foreach)
library(doParallel)
cl <- makeCluster(3, type = "FORK")
registerDoParallel(cl)
library(R6)
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
source("tools/CommonTools.R")
GeneralisedNadarayaWatson <- R6Class("GeneralisedNadarayaWatson",
public = list(
X_train = NULL,
Y_train = NULL,
A = NULL,
# max_threads = max_threads,
initialize = function(){
self$X_train <- NULL
self$Y_train <- NULL
self$A <- NULL
},
train = function(X_train, Y_train, w_coeff){
if (!is.vector(X_train) |
!is.vector(Y_train) |
!is.matrix(w_coeff))
{stop("Not correct class atributes")}
if (any(c(length(X_train), length(Y_train), nrow(w_coeff)) !=
rep(length(X_train), 3)))
{stop("Not correct input dimensions")}
self$X_train <- X_train
self$Y_train <- Y_train
self$A <- acoeff(w_coeff)
},
predict = function(X_test, h){
if (is.numeric(X_test) != TRUE | is.numeric(h) != TRUE)
{stop("Not correct class atributes")}
if (is.null(self$X_train) |
is.null(self$Y_train) |
is.null(self$A))
{stop("The model was not trained correctly")}
if (!is.null(self$A))
{if (any(is.na(self$A))) {stop("The model coefficients are not numbers")}}
results <- sapply(X_test,
function(x, h){
res <- nw_any_components(x, self$X_train, self$Y_train, h, self$A)
return(res)
}, h = h)
return(t(results))
},
predict_in_parallel = function(X_test, h){
n_rows <- length(X_test)
list_of_parts <- split_k_parts(k = 3, nrows = n_rows)
res <- foreach(each_part = list_of_parts,
.combine = list,
.multicombine = TRUE,
.export = "self") %dopar% {
self$predict(X_test[as.vector(each_part)], h)
}
return(do.call(rbind, res))
}
)
)
gnw <- GeneralisedNadarayaWatson$new()
gnw$train(X, Y, W)
Xtest <- as.vector(cv_small[[1]][, "math"])
prediction_no_parallel <- gnw$predict(Xtest, 1)
prediction_in_parallel <- gnw$predict_in_parallel(Xtest, 1)
stopCluster(cl)
prediction_in_parallel
prediction_no_parallel
all(prediction_in_parallel == prediction_no_parallel)
stopCluster(cl)
source("tools/GeneralizedNadarayaWatson.R")
df <- read.csv2(file ="/home/administrator/workplace/univ/ZNOandVoating/input.csv", header=FALSE, sep=";", dec=",")
names(df) <- c("ukr","math", "pro-ukr", "radical", "oposition", "small", "not_voted")
head(df)
source("tools/DataSplitTools.R")
source("tools/DataSplitTools.R")
source("tools/DataSplitTools.R")
source("tools/DataSplitTools.R")
df <- read.csv2(file ="/home/administrator/workplace/univ/ZNOandVoating/input.csv", header=FALSE, sep=";", dec=",")
names(df) <- c("ukr","math", "pro-ukr", "radical", "oposition", "small", "not_voted")
head(df)
source("tools/DataSplitTools.R")
source("tools/DataSplitTools.R")
cv_split <- cross_validation_split(df)
cv_small <- list("1" = cv_split[[1]][1:20, ], "2"=cv_split[[2]][1:20, ])
Xtest <- as.vector(cv_small[[1]][, "math"])
X<- as.vector(cv_small[[1]][, "math"]); Y <- as.vector(cv_small[[1]][, "ukr"]); W <- as.matrix(cv_small[[1]][, -c(1, 2)])
gnw <- GeneralisedNadarayaWatson()
source("tools/GeneralizedNadarayaWatson.R")
gnw <- GeneralisedNadarayaWatson()
source("tools/GeneralizedNadarayaWatson.R")
gnw <- GeneralisedNadarayaWatson$new()
gnw$train(X, Y, W)
pred_no_parallel <- gnw$predict(X_test, 1)
pred_no_parallel <- gnw$predict(Xtest, 1)
pred_no_parallel
gnw$run_cluster()
pred_in_parallel <- gnw$predict_in_parallel(Xtest, 1)
gnw$stop_cluster()
pred_in_parallel
source("tools/DataSplitTools.R")
source("tools/GeneralizedNadarayaWatson.R")
df <- read.csv2(file ="/home/administrator/workplace/univ/ZNOandVoating/input.csv", header = FALSE, sep = ";",dec=',')
names(df) <- c("ukr", "math", "pro-ukr", "radical", "oposition", "small", "not_voted")
head(df)
cv_split <- cross_validation_split(df)
cv_small <- list("1"=cv_split[[1]][1:20, ], "2"=cv_split[[2]][1:20, ])
X<- as.vector(cv_small[[1]][, "math"]); Y <- as.vector(cv_small[[1]][, "ukr"]); W <- as.matrix(cv_small[[1]][, -c(1, 2)])
Xtest <- as.vector(cv_small[[1]][, "math"])
gnw <- GeneralisedNadarayaWatson$new()
gnw$train(X, Y, W)
pr_no_parallel <- gnw$predict(Xtest, 1)
gnw$run_cluster()
gnw$max_threads
registerDoParallel(gnw$max_threads, type = "FORK")
registerDoParallel(3, type = "FORK")
library(foreach)
library(doParallel)
registerDoParallel(3, type = "FORK")
registerDoParallel(3)
sink("/home/administrator/new_file.R")
