instance$stop_cluster()
X_train
X_test
w_coeff
X_train <- rep(0.5, 2)
Y_train <- rep(2, 2)
X_test <- rep(0.5, 2)
X_test2 <- c(0.5, 0.7)
w_coeff <- wcoeff_two_components(n = 2)
w_coeff2 <- rbind(c(0.8, 0.1, 0.1),
c(0.05, 0.90, 0.05),
c(0.2, 0.1, 0.7))
instance <- GeneralisedNadarayaWatson$new()
instance$train(X_train, Y_train, w_coeff)
instance$run_cluster(2)
instance$predict_in_parallel(X_test, w_coeff, 1)
instance$predict(X_test, w_coeff, 1)
instance$A
nw_any_components(0.5, X_train, Y_train, 1, instance$A)
library(R6)
library(foreach)
library(doParallel)
max_threads <- detectCores() - 1
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
source("tools/CommonTools.R")
GeneralisedNadarayaWatson <- R6Class("GeneralisedNadarayaWatson",
public = list(
X_train = NULL,
Y_train = NULL,
A = NULL,
max_threads = max_threads,
initialize = function(){
self$X_train <- NULL
self$Y_train <- NULL
self$A <- NULL
self$max_threads <- max_threads
},
train = function(X_train, Y_train, W_train){
if (!is.vector(X_train, mode = "numeric") |
!is.vector(Y_train, mode = "numeric") |
!is.matrix(W_train))
{stop("Not correct class attributes")}
if (any(c(length(X_train), length(Y_train), nrow(W_train)) !=
rep(length(X_train), 3)))
{stop("Not correct input dimensions")}
self$X_train <- X_train
self$Y_train <- Y_train
self$A <- acoeff(W_train)
},
predict = function(X_test, W_test, h){
print("X_test:"); print(X_test)
print("W_test:"); print(W_test)
print("h:"); print(h)
print(self$A)
if (is.numeric(X_test) != TRUE |
is.numeric(h) != TRUE |
is.matrix(W_test) != TRUE)
{stop("Not correct class attributes")}
if (is.null(self$X_train) |
is.null(self$Y_train) |
is.null(self$A))
{stop("The model was not trained correctly")}
if (!is.null(self$A))
{if (any(is.na(self$A))) {stop("The model coefficients are not numbers")}}
if (length(X_test) != nrow(W_test))
{stop("Not correct input dimensions")}
results <- sapply(X_test,
function(x, h){
res <- nw_any_components(x, self$X_train, self$Y_train, h, self$A)
return(res)
}, h = h)
return(list("prediction" = t(results), "A_test" = acoeff(W_test)))
},
predict_in_parallel = function(X_test, W_test, h){
if (is.numeric(X_test) != TRUE |
is.numeric(h) != TRUE |
is.matrix(W_test) != TRUE)
{stop("Not correct class attributes")}
if (is.null(self$X_train) |
is.null(self$Y_train) |
is.null(self$A))
{stop("The model was not trained correctly")}
if (!is.null(self$A))
{if (any(is.na(self$A))) {stop("The model coefficients are not numbers")}}
if (length(X_test) != nrow(W_test))
{stop("Not correct input dimensions")}
n_rows <- length(X_test)
list_of_parts <- split_k_parts(k = self$max_threads, nrows = n_rows)
res <- foreach(each_part = list_of_parts,
.combine = list,
.multicombine = TRUE,
.export = c("self", "W_test", "h")) %dopar% {
pr <- self$predict(as.vector(X_test[each_part]),
matrix(W_test[each_part, ], nrow = length(each_part)),
h)
pr
}
return(list("prediction" = res))
},
stop_cluster = function(){
stopImplicitCluster()
},
run_cluster = function(max_threads = self$max_threads){
self$max_threads = max_threads
registerDoParallel(self$max_threads)
}
)
)
instance$stop_cluster()
instance$stop_cluster()
instance <- GeneralisedNadarayaWatson$new()
instance$train(X_train, Y_train, w_coeff)
instance$run_cluster(2)
instance$predict_in_parallel(X_test, w_coeff, 1)
instance$stop_cluster()
library(R6)
library(foreach)
library(doParallel)
max_threads <- detectCores() - 1
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
source("tools/CommonTools.R")
GeneralisedNadarayaWatson <- R6Class("GeneralisedNadarayaWatson",
public = list(
X_train = NULL,
Y_train = NULL,
A = NULL,
max_threads = max_threads,
initialize = function(){
self$X_train <- NULL
self$Y_train <- NULL
self$A <- NULL
self$max_threads <- max_threads
},
train = function(X_train, Y_train, W_train){
if (!is.vector(X_train, mode = "numeric") |
!is.vector(Y_train, mode = "numeric") |
!is.matrix(W_train))
{stop("Not correct class attributes")}
if (any(c(length(X_train), length(Y_train), nrow(W_train)) !=
rep(length(X_train), 3)))
{stop("Not correct input dimensions")}
self$X_train <- X_train
self$Y_train <- Y_train
self$A <- acoeff(W_train)
},
predict = function(X_test, W_test, h){
print("X_test:"); print(X_test)
print("W_test:"); print(W_test)
print("h:"); print(h)
print(self$A)
if (is.numeric(X_test) != TRUE |
is.numeric(h) != TRUE |
is.matrix(W_test) != TRUE)
{stop("Not correct class attributes")}
if (is.null(self$X_train) |
is.null(self$Y_train) |
is.null(self$A))
{stop("The model was not trained correctly")}
if (!is.null(self$A))
{if (any(is.na(self$A))) {stop("The model coefficients are not numbers")}}
if (length(X_test) != nrow(W_test))
{stop("Not correct input dimensions")}
results <- sapply(X_test,
function(x, h){
res <- nw_any_components(x, self$X_train, self$Y_train, h, self$A)
return(res)
}, h = h)
return(list("prediction" = t(results), "A_test" = acoeff(W_test)))
},
predict_in_parallel = function(X_test, W_test, h){
if (is.numeric(X_test) != TRUE |
is.numeric(h) != TRUE |
is.matrix(W_test) != TRUE)
{stop("Not correct class attributes")}
if (is.null(self$X_train) |
is.null(self$Y_train) |
is.null(self$A))
{stop("The model was not trained correctly")}
if (!is.null(self$A))
{if (any(is.na(self$A))) {stop("The model coefficients are not numbers")}}
if (length(X_test) != nrow(W_test))
{stop("Not correct input dimensions")}
n_rows <- length(X_test)
list_of_parts <- split_k_parts(k = self$max_threads, nrows = n_rows)
res <- foreach(each_part = list_of_parts,
.combine = list,
.multicombine = TRUE,
.export = c("self", "W_test", "h")) %dopar% {
pr <- list(as.vector(X_test[each_part]),
matrix(W_test[each_part, ], nrow = length(each_part)),
h)
pr
}
return(list("prediction" = res))
},
stop_cluster = function(){
stopImplicitCluster()
},
run_cluster = function(max_threads = self$max_threads){
self$max_threads = max_threads
registerDoParallel(self$max_threads)
}
)
)
instance$stop_cluster()
instance$stop_cluster()
instance <- GeneralisedNadarayaWatson$new()
instance$train(X_train, Y_train, w_coeff)
instance$run_cluster(2)
instance$predict_in_parallel(X_test, w_coeff, 1)
library(R6)
library(foreach)
library(doParallel)
max_threads <- detectCores() - 1
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
source("tools/CommonTools.R")
GeneralisedNadarayaWatson <- R6Class("GeneralisedNadarayaWatson",
public = list(
X_train = NULL,
Y_train = NULL,
A = NULL,
max_threads = max_threads,
initialize = function(){
self$X_train <- NULL
self$Y_train <- NULL
self$A <- NULL
self$max_threads <- max_threads
},
train = function(X_train, Y_train, W_train){
if (!is.vector(X_train, mode = "numeric") |
!is.vector(Y_train, mode = "numeric") |
!is.matrix(W_train))
{stop("Not correct class attributes")}
if (any(c(length(X_train), length(Y_train), nrow(W_train)) !=
rep(length(X_train), 3)))
{stop("Not correct input dimensions")}
self$X_train <- X_train
self$Y_train <- Y_train
self$A <- acoeff(W_train)
},
predict = function(X_test, W_test, h){
print("X_test:"); print(X_test)
print("W_test:"); print(W_test)
print("h:"); print(h)
print(self$A)
if (is.numeric(X_test) != TRUE |
is.numeric(h) != TRUE |
is.matrix(W_test) != TRUE)
{stop("Not correct class attributes")}
if (is.null(self$X_train) |
is.null(self$Y_train) |
is.null(self$A))
{stop("The model was not trained correctly")}
if (!is.null(self$A))
{if (any(is.na(self$A))) {stop("The model coefficients are not numbers")}}
if (length(X_test) != nrow(W_test))
{stop("Not correct input dimensions")}
results <- sapply(X_test,
function(x, h){
res <- nw_any_components(x, self$X_train, self$Y_train, h, self$A)
return(res)
}, h = h)
return(list("prediction" = t(results), "A_test" = acoeff(W_test)))
},
predict_in_parallel = function(X_test, W_test, h){
if (is.numeric(X_test) != TRUE |
is.numeric(h) != TRUE |
is.matrix(W_test) != TRUE)
{stop("Not correct class attributes")}
if (is.null(self$X_train) |
is.null(self$Y_train) |
is.null(self$A))
{stop("The model was not trained correctly")}
if (!is.null(self$A))
{if (any(is.na(self$A))) {stop("The model coefficients are not numbers")}}
if (length(X_test) != nrow(W_test))
{stop("Not correct input dimensions")}
n_rows <- length(X_test)
list_of_parts <- split_k_parts(k = self$max_threads, nrows = n_rows)
res <- foreach(each_part = list_of_parts,
.combine = list,
.multicombine = TRUE,
.export = c("self", "W_test", "h")) %dopar% {
pr <- list(as.vector(X_test[each_part]),
matrix(W_test[each_part, ], nrow = length(each_part)),
h)
nw_any_components(x=X_test[each_part],
X_train = self$X_train,
Y_train = self$Y_train,
h = h, A = self$A)
pr
}
return(list("prediction" = res))
},
stop_cluster = function(){
stopImplicitCluster()
},
run_cluster = function(max_threads = self$max_threads){
self$max_threads = max_threads
registerDoParallel(self$max_threads)
}
)
)
instance$stop_cluster()
instance <- GeneralisedNadarayaWatson$new()
instance$train(X_train, Y_train, w_coeff)
instance$run_cluster(2)
instance$predict_in_parallel(X_test, w_coeff, 1)
instance$stop_cluster()
library(R6)
library(foreach)
library(doParallel)
max_threads <- detectCores() - 1
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
source("tools/CommonTools.R")
GeneralisedNadarayaWatson <- R6Class("GeneralisedNadarayaWatson",
public = list(
X_train = NULL,
Y_train = NULL,
A = NULL,
max_threads = max_threads,
initialize = function(){
self$X_train <- NULL
self$Y_train <- NULL
self$A <- NULL
self$max_threads <- max_threads
},
train = function(X_train, Y_train, W_train){
if (!is.vector(X_train, mode = "numeric") |
!is.vector(Y_train, mode = "numeric") |
!is.matrix(W_train))
{stop("Not correct class attributes")}
if (any(c(length(X_train), length(Y_train), nrow(W_train)) !=
rep(length(X_train), 3)))
{stop("Not correct input dimensions")}
self$X_train <- X_train
self$Y_train <- Y_train
self$A <- acoeff(W_train)
},
predict = function(X_test, W_test, h){
print("X_test:"); print(X_test)
print("W_test:"); print(W_test)
print("h:"); print(h)
print(self$A)
if (is.numeric(X_test) != TRUE |
is.numeric(h) != TRUE |
is.matrix(W_test) != TRUE)
{stop("Not correct class attributes")}
if (is.null(self$X_train) |
is.null(self$Y_train) |
is.null(self$A))
{stop("The model was not trained correctly")}
if (!is.null(self$A))
{if (any(is.na(self$A))) {stop("The model coefficients are not numbers")}}
if (length(X_test) != nrow(W_test))
{stop("Not correct input dimensions")}
results <- sapply(X_test,
function(x, h){
res <- nw_any_components(x, self$X_train, self$Y_train, h, self$A)
return(res)
}, h = h)
return(list("prediction" = t(results), "A_test" = acoeff(W_test)))
},
predict_in_parallel = function(X_test, W_test, h){
if (is.numeric(X_test) != TRUE |
is.numeric(h) != TRUE |
is.matrix(W_test) != TRUE)
{stop("Not correct class attributes")}
if (is.null(self$X_train) |
is.null(self$Y_train) |
is.null(self$A))
{stop("The model was not trained correctly")}
if (!is.null(self$A))
{if (any(is.na(self$A))) {stop("The model coefficients are not numbers")}}
if (length(X_test) != nrow(W_test))
{stop("Not correct input dimensions")}
n_rows <- length(X_test)
list_of_parts <- split_k_parts(k = self$max_threads, nrows = n_rows)
res <- foreach(each_part = list_of_parts,
.combine = list,
.multicombine = TRUE,
.export = c("self", "W_test", "h")) %dopar% {
pr <- list(as.vector(X_test[each_part]),
matrix(W_test[each_part, ], nrow = length(each_part)),
h)
pr <- nw_any_components(x=X_test[each_part],
X_train = self$X_train,
Y_train = self$Y_train,
h = h, A = self$A)
pr
}
return(list("prediction" = res))
},
stop_cluster = function(){
stopImplicitCluster()
},
run_cluster = function(max_threads = self$max_threads){
self$max_threads = max_threads
registerDoParallel(self$max_threads)
}
)
)
instance$stop_cluster()
instance <- GeneralisedNadarayaWatson$new()
instance$train(X_train, Y_train, w_coeff)
instance$run_cluster(2)
instance$predict_in_parallel(X_test, w_coeff, 1)
instance$stop_cluster()
sapply(1, function(x){nw_any_components(0, X_train, Y_train, 1, instance$A)})
sapply(0.5, function(x){nw_any_components(x, X_train, Y_train, 1, instance$A)})
library(R6)
library(foreach)
library(doParallel)
max_threads <- detectCores() - 1
source("tools/NadarayaWatson.R")
source("tools/MVCweights.R")
source("tools/CommonTools.R")
GeneralisedNadarayaWatson <- R6Class("GeneralisedNadarayaWatson",
public = list(
X_train = NULL,
Y_train = NULL,
A = NULL,
max_threads = max_threads,
initialize = function(){
self$X_train <- NULL
self$Y_train <- NULL
self$A <- NULL
self$max_threads <- max_threads
},
train = function(X_train, Y_train, W_train){
if (!is.vector(X_train, mode = "numeric") |
!is.vector(Y_train, mode = "numeric") |
!is.matrix(W_train))
{stop("Not correct class attributes")}
if (any(c(length(X_train), length(Y_train), nrow(W_train)) !=
rep(length(X_train), 3)))
{stop("Not correct input dimensions")}
self$X_train <- X_train
self$Y_train <- Y_train
self$A <- acoeff(W_train)
},
predict = function(X_test, W_test, h){
print("X_test:"); print(X_test)
print("W_test:"); print(W_test)
print("h:"); print(h)
print(self$A)
if (is.numeric(X_test) != TRUE |
is.numeric(h) != TRUE |
is.matrix(W_test) != TRUE)
{stop("Not correct class attributes")}
if (is.null(self$X_train) |
is.null(self$Y_train) |
is.null(self$A))
{stop("The model was not trained correctly")}
if (!is.null(self$A))
{if (any(is.na(self$A))) {stop("The model coefficients are not numbers")}}
if (length(X_test) != nrow(W_test))
{stop("Not correct input dimensions")}
results <- sapply(X_test,
function(x, h){
res <- nw_any_components(x, self$X_train, self$Y_train, h, self$A)
return(res)
}, h = h)
return(list("prediction" = t(results), "A_test" = acoeff(W_test)))
},
predict_in_parallel = function(X_test, W_test, h){
if (is.numeric(X_test) != TRUE |
is.numeric(h) != TRUE |
is.matrix(W_test) != TRUE)
{stop("Not correct class attributes")}
if (is.null(self$X_train) |
is.null(self$Y_train) |
is.null(self$A))
{stop("The model was not trained correctly")}
if (!is.null(self$A))
{if (any(is.na(self$A))) {stop("The model coefficients are not numbers")}}
if (length(X_test) != nrow(W_test))
{stop("Not correct input dimensions")}
n_rows <- length(X_test)
list_of_parts <- split_k_parts(k = self$max_threads, nrows = n_rows)
res <- foreach(each_part = list_of_parts,
.combine = list,
.multicombine = TRUE,
.export = c("self", "W_test", "h")) %dopar% {
pr <- list(as.vector(X_test[each_part]),
matrix(W_test[each_part, ], nrow = length(each_part)),
h)
pr <- self$predict(X_test[each_part],
matrix(W_test[each_part, ], nrow = length(each_part)), h)
pr
}
return(list("prediction" = res))
},
stop_cluster = function(){
stopImplicitCluster()
},
run_cluster = function(max_threads = self$max_threads){
self$max_threads = max_threads
registerDoParallel(self$max_threads)
}
)
)
instance$stop_cluster()
instance <- GeneralisedNadarayaWatson$new()
instance$train(X_train, Y_train, w_coeff)
instance$run_cluster(2)
instance$predict_in_parallel(X_test, w_coeff, 1)
instance$stop_cluster()
